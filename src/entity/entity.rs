//! Core entity type representing a living individual.
//!
//! An Entity is the primary container for a simulated individual. It holds:
//! - Identity (EntityId)
//! - Species classification
//! - Age (Duration since birth)
//! - Life stage
//! - Individual state (personality, mood, needs, etc.)
//! - Relationship slots for connections to other entities
//! - Memory storage for episodic memories

use crate::context::EcologicalContext;
use crate::entity::{AffectiveState, PhysiologicalState};
use crate::enums::{
    ContextPath, DispositionPath, HexacoPath, LifeStage, MentalHealthPath, MoodPath, NeedsPath,
    PersonCharacteristicsPath, SocialCognitionPath, Species, StatePath,
};
use crate::memory::{EmotionalSnapshot, MemoryEntry, MemoryLayer, MemoryLayers, MemoryTag};
use crate::processor::DecayProcessor;
use crate::state::{EntityModelConfig, IndividualState};
use crate::types::{Alert, Duration, EntityId, MicrosystemId, RelationshipSlot, Timestamp};

/// The maximum number of relationship slots an entity can have.
pub const MAX_RELATIONSHIP_SLOTS: usize = 8;

/// Core entity representing a living individual with psychological state.
///
/// Entity is the primary container for simulation. It holds identity,
/// biological properties (species, age, life stage), psychological state,
/// and relationship hooks.
///
/// # Construction
///
/// Use [`EntityBuilder`] for fluent construction:
///
/// ```
/// use behavioral_pathways::entity::EntityBuilder;
/// use behavioral_pathways::enums::Species;
///
/// let entity = EntityBuilder::new()
///     .species(Species::Human)
///     .build()
///     .unwrap();
/// ```
///
/// # State Access
///
/// Access state values using typed paths:
///
/// ```
/// use behavioral_pathways::entity::EntityBuilder;
/// use behavioral_pathways::enums::{Species, StatePath, MoodPath};
///
/// let entity = EntityBuilder::new()
///     .species(Species::Human)
///     .build()
///     .unwrap();
///
/// let valence = entity.get_effective(StatePath::Mood(MoodPath::Valence));
/// ```
///
/// [`EntityBuilder`]: crate::entity::EntityBuilder
#[derive(Debug, Clone, PartialEq)]
pub struct Entity {
    /// Unique identifier for this entity.
    id: EntityId,

    /// Species classification.
    species: Species,

    /// Age as duration since birth.
    age: Duration,

    /// Birth date timestamp (optional).
    ///
    /// When set, age at any timestamp can be computed as:
    /// `query_timestamp - birth_date`
    ///
    /// When not set, age is computed from the anchor age adjusted
    /// by time difference from the anchor timestamp.
    birth_date: Option<Timestamp>,

    /// Current life stage.
    life_stage: LifeStage,

    /// Aggregate individual psychological state.
    individual_state: IndividualState,

    /// Relationship slots for connections to other entities.
    relationship_slots: [RelationshipSlot; MAX_RELATIONSHIP_SLOTS],

    /// Memory storage organized into layers.
    ///
    /// Memories are stored in four layers with different capacities:
    /// - Immediate: 10 entries (minutes-hours)
    /// - Short-term: 20 entries (days-weeks)
    /// - Long-term: 50 entries (months-years)
    /// - Legacy: Unlimited (milestone-triggered)
    memories: MemoryLayers,

    /// Ecological context (Bronfenbrenner's five layers).
    ///
    /// Contains microsystem instances, exosystem, macrosystem, and chronosystem
    /// context values that influence individual development.
    context: EcologicalContext,

    /// Pending alerts generated by threshold checks and spiral detection.
    ///
    /// Alerts accumulate during processing and should be consumed/cleared
    /// by the caller after each processing cycle.
    pending_alerts: Vec<Alert>,

    /// Configuration for this entity model (subsystem activation, thresholds, etc.).
    config: EntityModelConfig,
}

impl Entity {
    /// Creates a new entity with the given properties.
    ///
    /// This is an internal constructor. Use `EntityBuilder` for public construction.
    pub(crate) fn new(
        id: EntityId,
        species: Species,
        age: Duration,
        birth_date: Option<Timestamp>,
        life_stage: LifeStage,
        individual_state: IndividualState,
    ) -> Self {
        let config = EntityModelConfig::for_species(&species);
        Entity {
            id,
            species,
            age,
            birth_date,
            life_stage,
            individual_state,
            relationship_slots: Default::default(),
            memories: MemoryLayers::new(),
            context: EcologicalContext::default(),
            pending_alerts: Vec::new(),
            config,
        }
    }

    /// Creates a new entity with the given properties and context.
    ///
    /// This is an internal constructor. Use `EntityBuilder` for public construction.
    pub(crate) fn new_with_context(
        id: EntityId,
        species: Species,
        age: Duration,
        birth_date: Option<Timestamp>,
        life_stage: LifeStage,
        individual_state: IndividualState,
        context: EcologicalContext,
    ) -> Self {
        let config = EntityModelConfig::for_species(&species);
        Entity {
            id,
            species,
            age,
            birth_date,
            life_stage,
            individual_state,
            relationship_slots: Default::default(),
            memories: MemoryLayers::new(),
            context,
            pending_alerts: Vec::new(),
            config,
        }
    }

    // --- Identity and Biology ---

    /// Returns the entity's unique identifier.
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    ///
    /// let entity = EntityBuilder::new()
    ///     .id("person_001")
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// assert_eq!(entity.id().as_str(), "person_001");
    /// ```
    #[must_use]
    pub fn id(&self) -> &EntityId {
        &self.id
    }

    /// Returns the entity's species.
    #[must_use]
    pub fn species(&self) -> &Species {
        &self.species
    }

    /// Returns the entity's age.
    #[must_use]
    pub fn age(&self) -> Duration {
        self.age
    }

    /// Returns the entity's birth date if set.
    ///
    /// When set, age at any timestamp can be computed as:
    /// `query_timestamp - birth_date`
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    /// use behavioral_pathways::types::Timestamp;
    ///
    /// let entity = EntityBuilder::new()
    ///     .id("person_001")
    ///     .species(Species::Human)
    ///     .birth_date(Timestamp::from_ymd_hms(1990, 6, 15, 0, 0, 0))
    ///     .build()
    ///     .unwrap();
    ///
    /// assert!(entity.birth_date().is_some());
    /// ```
    #[must_use]
    pub fn birth_date(&self) -> Option<Timestamp> {
        self.birth_date
    }

    /// Returns the entity's life stage.
    #[must_use]
    pub fn life_stage(&self) -> LifeStage {
        self.life_stage
    }

    // --- State Access ---

    /// Returns a reference to the entity's individual state.
    #[must_use]
    pub fn individual_state(&self) -> &IndividualState {
        &self.individual_state
    }

    /// Returns a mutable reference to the entity's individual state.
    pub fn individual_state_mut(&mut self) -> &mut IndividualState {
        &mut self.individual_state
    }

    /// Gets the effective value (base + delta) for a state path.
    ///
    /// For computed paths (like ThwartedBelongingness), this returns the
    /// computed value. For stored paths, this returns base + delta.
    ///
    /// Returns `Some(value)` for all valid paths. Currently all paths are
    /// valid, so this always returns `Some`. The `Option` wrapper is for
    /// API consistency and future extensibility.
    ///
    /// # Arguments
    ///
    /// * `path` - The state path to query
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::{Species, StatePath, MoodPath};
    ///
    /// let entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// let valence = entity.get_effective(StatePath::Mood(MoodPath::Valence));
    /// assert!(valence.is_some());
    /// ```
    #[must_use]
    pub fn get_effective(&self, path: StatePath) -> Option<f64> {
        let value = match path {
            StatePath::Hexaco(p) => self.get_hexaco_effective(p),
            StatePath::Mood(p) => self.get_mood_effective(p),
            StatePath::Needs(p) => self.get_needs_effective(p),
            StatePath::SocialCognition(p) => self.get_social_cognition_effective(p),
            StatePath::MentalHealth(p) => self.get_mental_health_effective(p),
            StatePath::Disposition(p) => self.get_disposition_effective(p),
            StatePath::PersonCharacteristics(p) => self.get_person_characteristics_effective(p),
        };
        Some(f64::from(value))
    }

    /// Gets the base value for a state path.
    ///
    /// Returns `None` for computed paths that have no stored base value.
    ///
    /// # Arguments
    ///
    /// * `path` - The state path to query
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::{Species, StatePath, MoodPath, MentalHealthPath};
    ///
    /// let entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// // Stored paths return Some
    /// let base = entity.get_base(StatePath::Mood(MoodPath::Valence));
    /// assert!(base.is_some());
    ///
    /// // Computed paths return None
    /// let computed = entity.get_base(
    ///     StatePath::MentalHealth(MentalHealthPath::ThwartedBelongingness)
    /// );
    /// assert!(computed.is_none());
    /// ```
    #[must_use]
    pub fn get_base(&self, path: StatePath) -> Option<f64> {
        let value = match path {
            StatePath::Hexaco(p) => Some(self.get_hexaco_base(p)),
            StatePath::Mood(p) => Some(self.get_mood_base(p)),
            StatePath::Needs(p) => Some(self.get_needs_base(p)),
            StatePath::SocialCognition(p) => Some(self.get_social_cognition_base(p)),
            StatePath::MentalHealth(p) => self.get_mental_health_base(p),
            StatePath::Disposition(p) => Some(self.get_disposition_base(p)),
            StatePath::PersonCharacteristics(p) => self.get_person_characteristics_base(p),
        };
        value.map(f64::from)
    }

    /// Gets the delta value for a state path.
    ///
    /// Returns `None` for computed paths and HEXACO (which has no delta).
    ///
    /// # Arguments
    ///
    /// * `path` - The state path to query
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::{Species, StatePath, MoodPath};
    ///
    /// let entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// let delta = entity.get_delta(StatePath::Mood(MoodPath::Valence));
    /// assert!(delta.is_some());
    /// ```
    #[must_use]
    pub fn get_delta(&self, path: StatePath) -> Option<f64> {
        let value = match path {
            StatePath::Hexaco(_) => None, // HEXACO has no delta
            StatePath::Mood(p) => Some(self.get_mood_delta(p)),
            StatePath::Needs(p) => Some(self.get_needs_delta(p)),
            StatePath::SocialCognition(p) => Some(self.get_social_cognition_delta(p)),
            StatePath::MentalHealth(p) => self.get_mental_health_delta(p),
            StatePath::Disposition(p) => Some(self.get_disposition_delta(p)),
            StatePath::PersonCharacteristics(p) => self.get_person_characteristics_delta(p),
        };
        value.map(f64::from)
    }

    /// Returns the current PAD affective state.
    ///
    /// Per the PAD (Pleasure-Arousal-Dominance) model, affect is represented
    /// by three orthogonal dimensions. Physiological states (fatigue, stress)
    /// are NOT part of affect - use `query_physiological_state()` for those.
    #[must_use]
    pub fn query_affective_state(&self) -> AffectiveState {
        let state = self.individual_state();
        AffectiveState {
            valence: state.mood().valence_effective(),
            arousal: state.mood().arousal_effective(),
            dominance: state.mood().dominance_effective(),
        }
    }

    /// Returns the baseline PAD affective state (no deltas).
    ///
    /// Per the PAD model, this contains only valence, arousal, and dominance.
    /// Use `get_baseline_physiological()` for fatigue/stress baselines.
    #[must_use]
    pub fn get_baseline_affect(&self) -> AffectiveState {
        let state = self.individual_state();
        AffectiveState {
            valence: state.mood().valence_base(),
            arousal: state.mood().arousal_base(),
            dominance: state.mood().dominance_base(),
        }
    }

    /// Returns the current physiological state (fatigue and stress).
    ///
    /// Physiological states are separate from the PAD affective model.
    /// These track bodily needs rather than emotional experience.
    #[must_use]
    pub fn query_physiological_state(&self) -> PhysiologicalState {
        let state = self.individual_state();
        PhysiologicalState {
            fatigue: state.needs().fatigue_effective(),
            stress: state.needs().stress_effective(),
        }
    }

    /// Returns the baseline physiological state (no deltas).
    #[must_use]
    pub fn get_baseline_physiological(&self) -> PhysiologicalState {
        let state = self.individual_state();
        PhysiologicalState {
            fatigue: state.needs().fatigue_base(),
            stress: state.needs().stress_base(),
        }
    }

    // --- Time Advancement (Internal) ---

    /// Advances the entity forward in time.
    ///
    /// **INTERNAL METHOD**: This is used internally by `Simulation::state_at()` to
    /// compute state at future timestamps. Consumers should not call this directly;
    /// use the timestamp-based `Simulation` API instead.
    ///
    /// This applies decay to state values using the provided processor
    /// and updates the entity's age.
    ///
    /// # Arguments
    ///
    /// * `duration` - The real time that has elapsed
    /// * `processor` - The decay processor to use
    #[allow(dead_code)] // Used in unit tests
    pub(crate) fn advance(&mut self, duration: Duration, processor: &dyn DecayProcessor) {
        // Get time scale from species (convert f32 to f64)
        let time_scale = f64::from(self.species.time_scale());

        // === BIDIRECTIONAL CONTEXT PROCESSING ===

        // 1. CONTEXT-TO-PERSON: Apply context effects to individual state FIRST
        //    Only if proximal process gate passes (sufficient frequency & complexity)

        // Compute aggregate interaction frequency and complexity across microsystems
        let (avg_frequency, avg_complexity) = self.compute_aggregate_interaction_metrics();

        // Check proximal process gate using config thresholds
        let proximal_gate_passes = self
            .config
            .check_proximal_process_gate(avg_frequency, avg_complexity);

        if proximal_gate_passes {
            // Compute relationship quality (placeholder: average of relationship slots that are attached)
            let attached_count = self
                .relationship_slots
                .iter()
                .filter(|s| s.is_attached())
                .count();
            let relationship_quality = if attached_count > 0 {
                0.5 + 0.1 * (attached_count as f64).min(5.0) // 0.5 to 1.0 based on relationships
            } else {
                0.3 // Low relationship quality if no attachments
            };

            // --- Microsystem effects (aggregate stress/warmth) ---
            let (stress_adj, loneliness_adj) = self
                .context
                .compute_context_to_person_effects(relationship_quality);

            // Apply microsystem effects to person state
            if stress_adj.abs() > f32::EPSILON {
                self.individual_state
                    .needs_mut()
                    .add_stress_delta(stress_adj);
            }
            if loneliness_adj.abs() > f32::EPSILON {
                self.individual_state
                    .social_cognition_mut()
                    .add_loneliness_delta(loneliness_adj);
            }

            // --- Exosystem effects ---
            // Institutional support buffers stress (reduces stress delta)
            let institutional_support = self.context.exosystem().institutional_support;
            // Higher institutional support = stress buffer (negative stress adjustment)
            // Scale: 0.5 support = neutral, 1.0 = max buffer (-0.05), 0.0 = no buffer
            let exo_stress_buffer = ((institutional_support - 0.5) * 0.1) as f32;
            if exo_stress_buffer.abs() > f32::EPSILON {
                self.individual_state
                    .needs_mut()
                    .add_stress_delta(-exo_stress_buffer);
            }

            // --- Macrosystem effects ---
            // Cultural orientation affects belonging weight
            // Collectivist cultures increase belonging need satisfaction
            let belonging_weight = self.context.macrosystem().belonging_need_weight();
            // Apply belonging weight effect to loneliness
            // High belonging weight (collectivist) = reduces loneliness
            let macro_loneliness_adj = ((1.0 - belonging_weight) * 0.05) as f32;
            if macro_loneliness_adj.abs() > f32::EPSILON {
                self.individual_state
                    .social_cognition_mut()
                    .add_loneliness_delta(macro_loneliness_adj);
            }

            // Cultural stress adds to person stress
            let cultural_stress = self.context.macrosystem().cultural_stress;
            let macro_stress_adj = (cultural_stress * 0.05) as f32;
            if macro_stress_adj.abs() > f32::EPSILON {
                self.individual_state
                    .needs_mut()
                    .add_stress_delta(macro_stress_adj);
            }

            // --- Chronosystem effects ---
            // Off-time penalties from normative transitions add stress
            let off_time_stress = self.context.chronosystem().total_off_time_stress();
            let chrono_stress_adj = (off_time_stress * 0.1) as f32;
            if chrono_stress_adj.abs() > f32::EPSILON {
                self.individual_state
                    .needs_mut()
                    .add_stress_delta(chrono_stress_adj);
            }

            // Historical period instability affects stress
            let stability = self
                .context
                .chronosystem()
                .historical_period()
                .stability_level;
            let instability_stress = ((1.0 - stability) * 0.05) as f32;
            if instability_stress.abs() > f32::EPSILON {
                self.individual_state
                    .needs_mut()
                    .add_stress_delta(instability_stress);
            }
        }

        // 2. PERSON-TO-CONTEXT: Modify context based on updated state SECOND
        let hexaco = self.individual_state.hexaco();
        let extraversion = hexaco.extraversion();
        let conscientiousness = hexaco.conscientiousness();
        let agreeableness = hexaco.agreeableness();
        let neuroticism = hexaco.neuroticism();
        let grievance = self.individual_state.disposition().grievance_effective();
        self.context.apply_person_to_context_shaping(
            extraversion,
            conscientiousness,
            agreeableness,
            neuroticism,
            grievance,
        );

        // === STANDARD PROCESSING ===

        // Apply decay via processor
        processor.apply_decay(&mut self.individual_state, duration, time_scale);

        // Advance age
        self.age = self.age + duration;

        // Invalidate mesosystem cache so values are recomputed next access
        self.context.invalidate_mesosystem_cache();
    }

    /// Computes aggregate interaction frequency and complexity across all microsystems.
    ///
    /// Returns (avg_frequency, avg_complexity) in range [0.0, 1.0].
    /// If no microsystems exist, returns (0.0, 0.0).
    #[allow(dead_code)] // Used by advance() which is used in unit tests
    fn compute_aggregate_interaction_metrics(&self) -> (f64, f64) {
        let mut total_freq = 0.0;
        let mut total_complex = 0.0;
        let mut count = 0;

        for (_, microsystem) in self.context.microsystems_iter() {
            total_freq += microsystem.interaction_frequency();
            total_complex += microsystem.interaction_complexity();
            count += 1;
        }

        if count == 0 {
            return (0.0, 0.0);
        }

        (total_freq / count as f64, total_complex / count as f64)
    }

    // --- Relationship Slots ---

    /// Returns a reference to the relationship slots.
    #[must_use]
    pub fn relationship_slots(&self) -> &[RelationshipSlot; MAX_RELATIONSHIP_SLOTS] {
        &self.relationship_slots
    }

    /// Returns a mutable reference to the relationship slots.
    ///
    /// This is crate-internal for Phase 5 relationship management.
    #[allow(dead_code)]
    pub(crate) fn relationship_slots_mut(
        &mut self,
    ) -> &mut [RelationshipSlot; MAX_RELATIONSHIP_SLOTS] {
        &mut self.relationship_slots
    }

    // --- Context ---

    /// Returns a reference to the entity's ecological context.
    ///
    /// The ecological context contains all five Bronfenbrenner layers:
    /// microsystems, mesosystem (computed), exosystem, macrosystem, and chronosystem.
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    ///
    /// let entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// // Initially no microsystems
    /// assert_eq!(entity.context().microsystem_count(), 0);
    /// ```
    #[must_use]
    pub fn context(&self) -> &EcologicalContext {
        &self.context
    }

    /// Returns a mutable reference to the entity's ecological context.
    ///
    /// Allows modifying ecological layers (adding/removing microsystems,
    /// changing exosystem/macrosystem/chronosystem values).
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    /// use behavioral_pathways::context::{Microsystem, WorkContext};
    /// use behavioral_pathways::types::MicrosystemId;
    ///
    /// let mut entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// // Add a work microsystem
    /// let work_id = MicrosystemId::new("work_primary").unwrap();
    /// entity.context_mut().add_microsystem(work_id, Microsystem::new_work(WorkContext::default()));
    /// assert_eq!(entity.context().microsystem_count(), 1);
    /// ```
    pub fn context_mut(&mut self) -> &mut EcologicalContext {
        &mut self.context
    }

    // --- Configuration ---

    /// Returns a reference to the entity's model configuration.
    ///
    /// The configuration determines which subsystems are active, thresholds
    /// for proximal processes, and other entity-type-specific settings.
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::{Species, SubsystemId};
    ///
    /// let entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// // Human entities have mental health enabled
    /// assert!(entity.config().mental_health_enabled());
    /// ```
    #[must_use]
    pub fn config(&self) -> &EntityModelConfig {
        &self.config
    }

    /// Returns a mutable reference to the entity's model configuration.
    ///
    /// Allows modifying subsystem activation, thresholds, etc.
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    ///
    /// let mut entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// // Disable mental health tracking
    /// entity.config_mut().set_mental_health_enabled(false);
    /// assert!(!entity.config().mental_health_enabled());
    /// ```
    pub fn config_mut(&mut self) -> &mut EntityModelConfig {
        &mut self.config
    }

    /// Gets a context value by path.
    ///
    /// Convenience method that delegates to EcologicalContext.
    ///
    /// # Arguments
    ///
    /// * `path` - The context path to query
    ///
    /// # Returns
    ///
    /// The value at the path, or None if the path does not exist
    /// (e.g., microsystem ID not found).
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::{Species, ContextPath, MacrosystemPath};
    ///
    /// let entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// let power_distance = entity.get_context(
    ///     &ContextPath::Macrosystem(MacrosystemPath::PowerDistance)
    /// );
    /// assert!(power_distance.is_some());
    /// ```
    #[must_use]
    pub fn get_context(&self, path: &ContextPath) -> Option<f64> {
        self.context.get(path)
    }

    /// Sets a context value by path.
    ///
    /// Convenience method that delegates to EcologicalContext.
    ///
    /// # Arguments
    ///
    /// * `path` - The context path to modify
    /// * `value` - The new value
    ///
    /// # Returns
    ///
    /// `true` if the value was set, `false` if the path does not exist.
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::{Species, ContextPath, MacrosystemPath};
    ///
    /// let mut entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// entity.set_context(
    ///     &ContextPath::Macrosystem(MacrosystemPath::CulturalStress),
    ///     0.8
    /// );
    /// let stress = entity.get_context(
    ///     &ContextPath::Macrosystem(MacrosystemPath::CulturalStress)
    /// ).unwrap();
    /// assert!((stress - 0.8).abs() < 0.01);
    /// ```
    pub fn set_context(&mut self, path: &ContextPath, value: f64) -> bool {
        self.context.set(path, value)
    }

    // --- Memory ---

    /// Returns a reference to the entity's memory layers.
    ///
    /// Provides access to all memory layers for retrieval operations.
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    /// use behavioral_pathways::memory::MemoryTag;
    ///
    /// let entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// // Retrieve memories by tag (initially empty)
    /// let personal = entity.memories().retrieve_by_tag(MemoryTag::Personal);
    /// assert!(personal.is_empty());
    /// ```
    #[must_use]
    pub fn memories(&self) -> &MemoryLayers {
        &self.memories
    }

    /// Returns a mutable reference to the entity's memory layers.
    ///
    /// Provides access to add memories to layers.
    pub fn memories_mut(&mut self) -> &mut MemoryLayers {
        &mut self.memories
    }

    /// Creates a snapshot of the entity's current mood.
    ///
    /// Returns an EmotionalSnapshot capturing the current effective
    /// PAD (valence, arousal, dominance) values.
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    ///
    /// let mut entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// // Modify mood
    /// entity.individual_state_mut().mood_mut().add_valence_delta(0.5);
    ///
    /// let snapshot = entity.mood_snapshot();
    /// assert!((snapshot.valence() - 0.5).abs() < 0.01);
    /// ```
    #[must_use]
    pub fn mood_snapshot(&self) -> EmotionalSnapshot {
        EmotionalSnapshot::from_mood(self.individual_state.mood())
    }

    /// Creates a new memory with auto-captured mood snapshot.
    ///
    /// This is a convenience method that:
    /// 1. Creates a MemoryEntry with the given parameters
    /// 2. Captures the entity's current mood as an EmotionalSnapshot
    /// 3. Automatically selects the appropriate layer based on salience:
    ///    - 0.0-0.3: Immediate (routine events)
    ///    - 0.3-0.5: Short-term (notable events)
    ///    - 0.5-0.7: Long-term (significant events)
    ///    - 0.7-1.0: Legacy (major/defining events)
    ///
    /// # Arguments
    ///
    /// * `summary` - One-sentence summary of the memory
    /// * `participants` - Entities involved in the memory
    /// * `tags` - Categorization tags
    /// * `salience` - Importance (0.0-1.0)
    /// * `microsystem_context` - Optional context where memory was formed
    ///
    /// # Returns
    ///
    /// The created MemoryEntry (a clone, since the original is stored in layers).
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    /// use behavioral_pathways::memory::MemoryTag;
    /// use behavioral_pathways::types::EntityId;
    ///
    /// let mut entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// let other = EntityId::new("friend_001").unwrap();
    /// let memory = entity.create_memory(
    ///     "Had a meaningful conversation",
    ///     vec![other],
    ///     vec![MemoryTag::Personal, MemoryTag::Support],
    ///     0.7,
    ///     None,
    /// );
    ///
    /// // High salience (0.7) -> Legacy layer
    /// assert_eq!(entity.memories().legacy_count(), 1);
    /// assert_eq!(memory.summary(), "Had a meaningful conversation");
    /// ```
    pub fn create_memory(
        &mut self,
        summary: impl Into<String>,
        participants: Vec<EntityId>,
        tags: Vec<MemoryTag>,
        salience: f32,
        microsystem_context: Option<MicrosystemId>,
    ) -> MemoryEntry {
        let layer = Self::layer_for_salience(salience);
        self.create_memory_in_layer(
            layer,
            summary,
            participants,
            tags,
            salience,
            microsystem_context,
        )
    }

    /// Creates a new memory in a specific layer with auto-captured mood snapshot.
    ///
    /// This method allows explicit layer selection when the automatic salience-based
    /// layer selection is not appropriate.
    ///
    /// # Arguments
    ///
    /// * `layer` - The memory layer to add to
    /// * `summary` - One-sentence summary of the memory
    /// * `participants` - Entities involved in the memory
    /// * `tags` - Categorization tags
    /// * `salience` - Importance (0.0-1.0)
    /// * `microsystem_context` - Optional context where memory was formed
    ///
    /// # Returns
    ///
    /// The created MemoryEntry (a clone, since the original is stored in layers).
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    /// use behavioral_pathways::memory::{MemoryTag, MemoryLayer};
    /// use behavioral_pathways::types::EntityId;
    ///
    /// let mut entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// let other = EntityId::new("friend_001").unwrap();
    /// let memory = entity.create_memory_in_layer(
    ///     MemoryLayer::ShortTerm,
    ///     "Had a meaningful conversation",
    ///     vec![other],
    ///     vec![MemoryTag::Personal, MemoryTag::Support],
    ///     0.7,
    ///     None,
    /// );
    ///
    /// assert_eq!(entity.memories().short_term_count(), 1);
    /// assert_eq!(memory.summary(), "Had a meaningful conversation");
    /// ```
    pub fn create_memory_in_layer(
        &mut self,
        layer: MemoryLayer,
        summary: impl Into<String>,
        participants: Vec<EntityId>,
        tags: Vec<MemoryTag>,
        salience: f32,
        microsystem_context: Option<MicrosystemId>,
    ) -> MemoryEntry {
        let snapshot = self.mood_snapshot();
        let mut entry = MemoryEntry::new(self.age, summary)
            .with_participants(participants)
            .with_tags(tags)
            .with_salience(salience)
            .with_emotional_snapshot(snapshot);

        if let Some(context) = microsystem_context {
            entry = entry.with_microsystem_context(context);
        }

        let result = entry.clone();
        self.memories.add(layer, entry);
        result
    }

    /// Determines the appropriate memory layer based on salience.
    ///
    /// Salience thresholds:
    /// - 0.0-0.3: Immediate (routine events)
    /// - 0.3-0.5: Short-term (notable events)
    /// - 0.5-0.7: Long-term (significant events)
    /// - 0.7-1.0: Legacy (major/defining events)
    #[must_use]
    fn layer_for_salience(salience: f32) -> MemoryLayer {
        if salience < 0.3 {
            MemoryLayer::Immediate
        } else if salience < 0.5 {
            MemoryLayer::ShortTerm
        } else if salience < 0.7 {
            MemoryLayer::LongTerm
        } else {
            MemoryLayer::Legacy
        }
    }

    /// Retrieves memories congruent with the entity's current mood.
    ///
    /// Convenience method that passes the entity's current mood to
    /// the memory layer's mood-congruent retrieval.
    ///
    /// # Arguments
    ///
    /// * `min_congruence` - Minimum congruence threshold (0.0-1.0)
    ///
    /// # Returns
    ///
    /// Vector of memory references ordered by salience (highest first).
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    ///
    /// let entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// // With no memories, returns empty
    /// let congruent = entity.recall_mood_congruent(0.5);
    /// assert!(congruent.is_empty());
    /// ```
    #[must_use]
    pub fn recall_mood_congruent(&self, min_congruence: f32) -> Vec<&MemoryEntry> {
        self.memories
            .retrieve_mood_congruent(self.individual_state.mood(), min_congruence)
    }

    // --- Alerts ---

    /// Returns a reference to the entity's pending alerts.
    ///
    /// Alerts accumulate during processing when thresholds are crossed
    /// or feedback loops are detected. The caller should consume and
    /// clear alerts after each processing cycle.
    ///
    /// # Examples
    ///
    /// ```
    /// use behavioral_pathways::entity::EntityBuilder;
    /// use behavioral_pathways::enums::Species;
    ///
    /// let entity = EntityBuilder::new()
    ///     .species(Species::Human)
    ///     .build()
    ///     .unwrap();
    ///
    /// // Newly created entities have no alerts
    /// assert!(entity.alerts().is_empty());
    /// ```
    #[must_use]
    pub fn alerts(&self) -> &[Alert] {
        &self.pending_alerts
    }

    /// Adds an alert to the entity's pending alerts.
    ///
    /// This is typically called by processors when thresholds are
    /// crossed or feedback loops are detected.
    pub fn push_alert(&mut self, alert: Alert) {
        self.pending_alerts.push(alert);
    }

    /// Clears all pending alerts.
    ///
    /// Call this after consuming alerts to reset for the next
    /// processing cycle.
    pub fn clear_alerts(&mut self) {
        self.pending_alerts.clear();
    }

    /// Takes and returns all pending alerts, leaving the entity with no alerts.
    ///
    /// This is useful for consuming alerts in a single operation.
    #[must_use]
    pub fn take_alerts(&mut self) -> Vec<Alert> {
        std::mem::take(&mut self.pending_alerts)
    }

    // --- Private Helper Methods ---

    fn get_hexaco_effective(&self, path: HexacoPath) -> f32 {
        let h = self.individual_state.hexaco();
        match path {
            HexacoPath::Openness => h.openness(),
            HexacoPath::Conscientiousness => h.conscientiousness(),
            HexacoPath::Extraversion => h.extraversion(),
            HexacoPath::Agreeableness => h.agreeableness(),
            HexacoPath::Neuroticism => h.neuroticism(),
            HexacoPath::HonestyHumility => h.honesty_humility(),
        }
    }

    fn get_hexaco_base(&self, path: HexacoPath) -> f32 {
        // HEXACO is trait-like, no delta, so base equals effective
        self.get_hexaco_effective(path)
    }

    fn get_mood_effective(&self, path: MoodPath) -> f32 {
        let m = self.individual_state.mood();
        match path {
            MoodPath::Valence => m.valence_effective(),
            MoodPath::Arousal => m.arousal_effective(),
            MoodPath::Dominance => m.dominance_effective(),
        }
    }

    fn get_mood_base(&self, path: MoodPath) -> f32 {
        let m = self.individual_state.mood();
        match path {
            MoodPath::Valence => m.valence_base(),
            MoodPath::Arousal => m.arousal_base(),
            MoodPath::Dominance => m.dominance_base(),
        }
    }

    fn get_mood_delta(&self, path: MoodPath) -> f32 {
        let m = self.individual_state.mood();
        match path {
            MoodPath::Valence => m.valence_delta(),
            MoodPath::Arousal => m.arousal_delta(),
            MoodPath::Dominance => m.dominance_delta(),
        }
    }

    fn get_needs_effective(&self, path: NeedsPath) -> f32 {
        let n = self.individual_state.needs();
        match path {
            NeedsPath::Fatigue => n.fatigue_effective(),
            NeedsPath::Stress => n.stress_effective(),
            NeedsPath::Purpose => n.purpose_effective(),
        }
    }

    fn get_needs_base(&self, path: NeedsPath) -> f32 {
        let n = self.individual_state.needs();
        match path {
            NeedsPath::Fatigue => n.fatigue_base(),
            NeedsPath::Stress => n.stress_base(),
            NeedsPath::Purpose => n.purpose_base(),
        }
    }

    fn get_needs_delta(&self, path: NeedsPath) -> f32 {
        let n = self.individual_state.needs();
        match path {
            NeedsPath::Fatigue => n.fatigue().delta(),
            NeedsPath::Stress => n.stress().delta(),
            NeedsPath::Purpose => n.purpose().delta(),
        }
    }

    fn get_social_cognition_effective(&self, path: SocialCognitionPath) -> f32 {
        let social = self.individual_state.social_cognition();
        match path {
            SocialCognitionPath::Loneliness => social.loneliness_effective(),
            SocialCognitionPath::PerceivedReciprocalCaring => {
                social.perceived_reciprocal_caring_effective()
            }
            SocialCognitionPath::PerceivedLiability => social.perceived_liability_effective(),
            SocialCognitionPath::SelfHate => social.self_hate_effective(),
            SocialCognitionPath::PerceivedCompetence => social.perceived_competence_effective(),
        }
    }

    fn get_social_cognition_base(&self, path: SocialCognitionPath) -> f32 {
        let social = self.individual_state.social_cognition();
        match path {
            SocialCognitionPath::Loneliness => social.loneliness_base(),
            SocialCognitionPath::PerceivedReciprocalCaring => {
                social.perceived_reciprocal_caring_base()
            }
            SocialCognitionPath::PerceivedLiability => social.perceived_liability_base(),
            SocialCognitionPath::SelfHate => social.self_hate_base(),
            SocialCognitionPath::PerceivedCompetence => social.perceived_competence_base(),
        }
    }

    fn get_social_cognition_delta(&self, path: SocialCognitionPath) -> f32 {
        let social = self.individual_state.social_cognition();
        match path {
            SocialCognitionPath::Loneliness => social.loneliness().delta(),
            SocialCognitionPath::PerceivedReciprocalCaring => {
                social.perceived_reciprocal_caring().delta()
            }
            SocialCognitionPath::PerceivedLiability => social.perceived_liability().delta(),
            SocialCognitionPath::SelfHate => social.self_hate().delta(),
            SocialCognitionPath::PerceivedCompetence => social.perceived_competence().delta(),
        }
    }

    fn get_mental_health_effective(&self, path: MentalHealthPath) -> f32 {
        let mh = self.individual_state.mental_health();
        let social = self.individual_state.social_cognition();

        match path {
            MentalHealthPath::Depression => mh.depression_effective(),
            MentalHealthPath::SelfWorth => mh.self_worth_effective(),
            MentalHealthPath::Hopelessness => mh.hopelessness_effective(),
            MentalHealthPath::InterpersonalHopelessness => {
                mh.interpersonal_hopelessness_effective()
            }
            MentalHealthPath::AcquiredCapability => mh.acquired_capability_effective(),
            // Computed values
            MentalHealthPath::ThwartedBelongingness => mh.compute_thwarted_belongingness(social),
            MentalHealthPath::PerceivedBurdensomeness => mh.compute_perceived_burdensomeness(social),
            MentalHealthPath::SuicidalDesire => mh.compute_suicidal_desire(social),
            MentalHealthPath::AttemptRisk => mh.compute_attempt_risk(social),
        }
    }

    fn get_mental_health_base(&self, path: MentalHealthPath) -> Option<f32> {
        let mh = self.individual_state.mental_health();

        match path {
            MentalHealthPath::Depression => Some(mh.depression().base()),
            MentalHealthPath::SelfWorth => Some(mh.self_worth().base()),
            MentalHealthPath::Hopelessness => Some(mh.hopelessness().base()),
            MentalHealthPath::InterpersonalHopelessness => {
                Some(mh.interpersonal_hopelessness().base())
            }
            MentalHealthPath::AcquiredCapability => Some(mh.acquired_capability().base()),
            // Computed values have no base
            MentalHealthPath::ThwartedBelongingness
            | MentalHealthPath::PerceivedBurdensomeness
            | MentalHealthPath::SuicidalDesire
            | MentalHealthPath::AttemptRisk => None,
        }
    }

    fn get_mental_health_delta(&self, path: MentalHealthPath) -> Option<f32> {
        let mh = self.individual_state.mental_health();

        match path {
            MentalHealthPath::Depression => Some(mh.depression().delta()),
            MentalHealthPath::SelfWorth => Some(mh.self_worth().delta()),
            MentalHealthPath::Hopelessness => Some(mh.hopelessness().delta()),
            MentalHealthPath::InterpersonalHopelessness => {
                Some(mh.interpersonal_hopelessness().delta())
            }
            MentalHealthPath::AcquiredCapability => Some(mh.acquired_capability().delta()),
            // Computed values have no delta
            MentalHealthPath::ThwartedBelongingness
            | MentalHealthPath::PerceivedBurdensomeness
            | MentalHealthPath::SuicidalDesire
            | MentalHealthPath::AttemptRisk => None,
        }
    }

    fn get_disposition_effective(&self, path: DispositionPath) -> f32 {
        let d = self.individual_state.disposition();
        match path {
            DispositionPath::ImpulseControl => d.impulse_control_effective(),
            DispositionPath::Empathy => d.empathy_effective(),
            DispositionPath::Aggression => d.aggression_effective(),
            DispositionPath::Grievance => d.grievance_effective(),
            DispositionPath::Reactance => d.reactance_effective(),
            DispositionPath::TrustPropensity => d.trust_propensity_effective(),
        }
    }

    fn get_disposition_base(&self, path: DispositionPath) -> f32 {
        let d = self.individual_state.disposition();
        match path {
            DispositionPath::ImpulseControl => d.impulse_control().base(),
            DispositionPath::Empathy => d.empathy().base(),
            DispositionPath::Aggression => d.aggression().base(),
            DispositionPath::Grievance => d.grievance().base(),
            DispositionPath::Reactance => d.reactance().base(),
            DispositionPath::TrustPropensity => d.trust_propensity().base(),
        }
    }

    fn get_disposition_delta(&self, path: DispositionPath) -> f32 {
        let d = self.individual_state.disposition();
        match path {
            DispositionPath::ImpulseControl => d.impulse_control().delta(),
            DispositionPath::Empathy => d.empathy().delta(),
            DispositionPath::Aggression => d.aggression().delta(),
            DispositionPath::Grievance => d.grievance().delta(),
            DispositionPath::Reactance => d.reactance().delta(),
            DispositionPath::TrustPropensity => d.trust_propensity().delta(),
        }
    }

    fn get_person_characteristics_effective(&self, path: PersonCharacteristicsPath) -> f32 {
        let pc = self.individual_state.person_characteristics();
        match path {
            PersonCharacteristicsPath::CognitiveAbility => pc.cognitive_ability_effective(),
            PersonCharacteristicsPath::EmotionalRegulationAssets => {
                pc.emotional_regulation_assets_effective()
            }
            PersonCharacteristicsPath::SocialCapital => pc.social_capital_effective(),
            PersonCharacteristicsPath::MaterialSecurity => pc.material_security_effective(),
            PersonCharacteristicsPath::ExperienceDiversity => pc.experience_diversity_effective(),
            PersonCharacteristicsPath::BaselineMotivation => pc.baseline_motivation_effective(),
            PersonCharacteristicsPath::PersistenceTendency => pc.persistence_tendency_effective(),
            PersonCharacteristicsPath::CuriosityTendency => pc.curiosity_tendency_effective(),
            // Computed composites
            PersonCharacteristicsPath::Resource => pc.resource(),
            PersonCharacteristicsPath::Force => pc.force(),
        }
    }

    fn get_person_characteristics_base(&self, path: PersonCharacteristicsPath) -> Option<f32> {
        let pc = self.individual_state.person_characteristics();
        match path {
            PersonCharacteristicsPath::CognitiveAbility => Some(pc.cognitive_ability().base()),
            PersonCharacteristicsPath::EmotionalRegulationAssets => {
                Some(pc.emotional_regulation_assets().base())
            }
            PersonCharacteristicsPath::SocialCapital => Some(pc.social_capital().base()),
            PersonCharacteristicsPath::MaterialSecurity => Some(pc.material_security().base()),
            PersonCharacteristicsPath::ExperienceDiversity => {
                Some(pc.experience_diversity().base())
            }
            PersonCharacteristicsPath::BaselineMotivation => Some(pc.baseline_motivation().base()),
            PersonCharacteristicsPath::PersistenceTendency => {
                Some(pc.persistence_tendency().base())
            }
            PersonCharacteristicsPath::CuriosityTendency => Some(pc.curiosity_tendency().base()),
            // Composite values have no base
            PersonCharacteristicsPath::Resource | PersonCharacteristicsPath::Force => None,
        }
    }

    fn get_person_characteristics_delta(&self, path: PersonCharacteristicsPath) -> Option<f32> {
        let pc = self.individual_state.person_characteristics();
        match path {
            PersonCharacteristicsPath::CognitiveAbility => Some(pc.cognitive_ability().delta()),
            PersonCharacteristicsPath::EmotionalRegulationAssets => {
                Some(pc.emotional_regulation_assets().delta())
            }
            PersonCharacteristicsPath::SocialCapital => Some(pc.social_capital().delta()),
            PersonCharacteristicsPath::MaterialSecurity => Some(pc.material_security().delta()),
            PersonCharacteristicsPath::ExperienceDiversity => {
                Some(pc.experience_diversity().delta())
            }
            PersonCharacteristicsPath::BaselineMotivation => Some(pc.baseline_motivation().delta()),
            PersonCharacteristicsPath::PersistenceTendency => {
                Some(pc.persistence_tendency().delta())
            }
            PersonCharacteristicsPath::CuriosityTendency => Some(pc.curiosity_tendency().delta()),
            // Composite values have no delta
            PersonCharacteristicsPath::Resource | PersonCharacteristicsPath::Force => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::entity::EntityBuilder;
    use crate::processor::NoOpDecayProcessor;

    // --- Entity Creation ---

    #[test]
    fn human_entity_creation() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        assert_eq!(entity.species(), &Species::Human);
    }

    #[test]
    fn entity_has_individual_state() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let state = entity.individual_state();
        // Verify we can access state components
        let _ = state.mood();
        let _ = state.needs();
        let _ = state.mental_health();
    }

    #[test]
    fn entity_has_species() {
        let entity = EntityBuilder::new().species(Species::Dog).build().unwrap();

        assert_eq!(entity.species(), &Species::Dog);
    }

    #[test]
    fn entity_has_life_stage() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .life_stage(LifeStage::Adult)
            .build()
            .unwrap();

        assert_eq!(entity.life_stage(), LifeStage::Adult);
    }

    #[test]
    fn entity_has_person_characteristics() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let pc = entity.individual_state().person_characteristics();
        // Verify we can access PC components
        let _ = pc.resource();
        let _ = pc.force();
    }

    // --- State Access ---

    #[test]
    fn entity_age_query() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .age(Duration::years(25))
            .build()
            .unwrap();

        assert_eq!(entity.age().as_years(), 25);
    }

    #[test]
    fn entity_get_effective_mood_valence() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let valence = entity
            .get_effective(StatePath::Mood(MoodPath::Valence))
            .unwrap();
        assert!(valence.abs() < 0.1); // Should be near neutral
    }

    #[test]
    fn entity_get_effective_mood_arousal() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let arousal = entity
            .get_effective(StatePath::Mood(MoodPath::Arousal))
            .unwrap();
        assert!(arousal.abs() < 0.1); // Should be near neutral
    }

    #[test]
    fn entity_get_effective_mood_dominance() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let dominance = entity
            .get_effective(StatePath::Mood(MoodPath::Dominance))
            .unwrap();
        assert!(dominance.abs() < 0.1); // Should be near neutral
    }

    #[test]
    fn entity_get_effective_needs_stress() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let stress = entity
            .get_effective(StatePath::Needs(NeedsPath::Stress))
            .unwrap();
        assert!(stress >= 0.0 && stress <= 1.0);
    }

    #[test]
    fn entity_get_effective_needs_fatigue() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let fatigue = entity
            .get_effective(StatePath::Needs(NeedsPath::Fatigue))
            .unwrap();
        assert!(fatigue >= 0.0 && fatigue <= 1.0);
    }

    #[test]
    fn entity_get_effective_mental_health_path() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let depression = entity
            .get_effective(StatePath::MentalHealth(MentalHealthPath::Depression))
            .unwrap();
        assert!(depression >= 0.0 && depression <= 1.0);
    }

    #[test]
    fn entity_get_effective_hexaco_path() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let openness = entity
            .get_effective(StatePath::Hexaco(HexacoPath::Openness))
            .unwrap();
        assert!(openness >= -1.0 && openness <= 1.0);
    }

    #[test]
    fn entity_get_effective_disposition_path() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let empathy = entity
            .get_effective(StatePath::Disposition(DispositionPath::Empathy))
            .unwrap();
        assert!(empathy >= 0.0 && empathy <= 1.0);
    }

    #[test]
    fn entity_get_effective_person_characteristics_path() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let cognitive = entity
            .get_effective(StatePath::PersonCharacteristics(
                PersonCharacteristicsPath::CognitiveAbility,
            ))
            .unwrap();
        assert!(cognitive >= 0.0 && cognitive <= 1.0);
    }

    #[test]
    fn entity_get_base_returns_base_only() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Add delta to mood
        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(0.3);

        let base = entity.get_base(StatePath::Mood(MoodPath::Valence)).unwrap();
        let effective = entity
            .get_effective(StatePath::Mood(MoodPath::Valence))
            .unwrap();

        // Base should not include delta
        // Use larger epsilon due to f32 -> f64 conversion precision
        assert!((effective - base - 0.3).abs() < 1e-6);
    }

    #[test]
    fn entity_get_delta_returns_delta_only() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(0.5);

        let delta = entity
            .get_delta(StatePath::Mood(MoodPath::Valence))
            .unwrap();
        // Use larger epsilon due to f32 -> f64 conversion precision
        assert!((delta - 0.5).abs() < 1e-6);
    }

    #[test]
    fn entity_get_computed_path_calls_compute() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // TB is computed from needs
        let tb = entity
            .get_effective(StatePath::MentalHealth(
                MentalHealthPath::ThwartedBelongingness,
            ))
            .unwrap();
        assert!(tb >= 0.0 && tb <= 1.0);
    }

    #[test]
    fn entity_get_base_on_computed_returns_none() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let base = entity.get_base(StatePath::MentalHealth(
            MentalHealthPath::ThwartedBelongingness,
        ));
        assert!(base.is_none());
    }

    // --- Relationship Hooks ---

    #[test]
    fn entity_has_relationship_slots() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let slots = entity.relationship_slots();
        assert_eq!(slots.len(), MAX_RELATIONSHIP_SLOTS);
    }

    #[test]
    fn entity_relationship_slot_empty_initially() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        for slot in entity.relationship_slots() {
            assert!(slot.is_empty());
        }
    }

    #[test]
    fn entity_relationship_slot_get_attached_none() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        for slot in entity.relationship_slots() {
            assert!(slot.get_attached().is_none());
        }
    }

    // --- Time Advancement ---

    #[test]
    fn entity_advance_calls_processor() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let original_age = entity.age();
        let processor = NoOpDecayProcessor::new();

        entity.advance(Duration::days(1), &processor);

        // Age should have increased
        assert_eq!(entity.age().as_days(), original_age.as_days() + 1);
    }

    #[test]
    fn entity_advance_with_stub_returns_unchanged() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Add some delta
        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(0.5);
        let delta_before = entity
            .get_delta(StatePath::Mood(MoodPath::Valence))
            .unwrap();

        // Advance with no-op processor
        let processor = NoOpDecayProcessor::new();
        entity.advance(Duration::years(10), &processor);

        // Delta should be unchanged (no-op)
        let delta_after = entity
            .get_delta(StatePath::Mood(MoodPath::Valence))
            .unwrap();
        // Use larger epsilon due to f32 -> f64 conversion precision
        assert!((delta_before - delta_after).abs() < 1e-6);
    }

    // --- Additional Tests ---

    #[test]
    fn entity_clone() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .age(Duration::years(30))
            .build()
            .unwrap();

        let cloned = entity.clone();

        assert_eq!(entity.id(), cloned.id());
        assert_eq!(entity.species(), cloned.species());
        assert_eq!(entity.age(), cloned.age());
    }

    #[test]
    fn entity_debug() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let debug = format!("{:?}", entity);
        assert!(debug.contains("Entity"));
    }

    #[test]
    fn entity_id() {
        let entity = EntityBuilder::new()
            .id("test_id")
            .species(Species::Human)
            .build()
            .unwrap();

        assert_eq!(entity.id().as_str(), "test_id");
    }

    #[test]
    fn entity_individual_state_mutable() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(0.3);

        assert!((entity.individual_state().mood().valence_delta() - 0.3).abs() < f32::EPSILON);
    }

    #[test]
    fn hexaco_has_no_delta() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let delta = entity.get_delta(StatePath::Hexaco(HexacoPath::Openness));
        assert!(delta.is_none());
    }

    #[test]
    fn all_needs_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        for path in NeedsPath::all() {
            let effective = entity.get_effective(StatePath::Needs(path)).unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::Needs(path));
            assert!(base.is_some());

            let delta = entity.get_delta(StatePath::Needs(path));
            assert!(delta.is_some());
        }
    }

    #[test]
    fn all_disposition_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        for path in DispositionPath::all() {
            let effective = entity.get_effective(StatePath::Disposition(path)).unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::Disposition(path));
            assert!(base.is_some());

            let delta = entity.get_delta(StatePath::Disposition(path));
            assert!(delta.is_some());
        }
    }

    #[test]
    fn all_mental_health_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        for path in MentalHealthPath::all() {
            let effective = entity.get_effective(StatePath::MentalHealth(path)).unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            if path.is_computed() {
                assert!(entity.get_base(StatePath::MentalHealth(path)).is_none());
                assert!(entity.get_delta(StatePath::MentalHealth(path)).is_none());
            } else {
                assert!(entity.get_base(StatePath::MentalHealth(path)).is_some());
                assert!(entity.get_delta(StatePath::MentalHealth(path)).is_some());
            }
        }
    }

    #[test]
    fn all_person_characteristics_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        for path in PersonCharacteristicsPath::all() {
            let effective = entity
                .get_effective(StatePath::PersonCharacteristics(path))
                .unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            if path.is_composite() {
                assert!(entity
                    .get_base(StatePath::PersonCharacteristics(path))
                    .is_none());
                assert!(entity
                    .get_delta(StatePath::PersonCharacteristics(path))
                    .is_none());
            } else {
                assert!(entity
                    .get_base(StatePath::PersonCharacteristics(path))
                    .is_some());
                assert!(entity
                    .get_delta(StatePath::PersonCharacteristics(path))
                    .is_some());
            }
        }
    }

    #[test]
    fn dog_entity_creation() {
        let entity = EntityBuilder::new().species(Species::Dog).build().unwrap();

        assert_eq!(entity.species(), &Species::Dog);
    }

    #[test]
    fn cat_entity_creation() {
        let entity = EntityBuilder::new().species(Species::Cat).build().unwrap();

        assert_eq!(entity.species(), &Species::Cat);
    }

    #[test]
    fn all_hexaco_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        for path in HexacoPath::all() {
            let effective = entity.get_effective(StatePath::Hexaco(path)).unwrap();
            assert!(effective >= -1.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::Hexaco(path));
            assert!(base.is_some());

            // HEXACO has no delta
            let delta = entity.get_delta(StatePath::Hexaco(path));
            assert!(delta.is_none());
        }
    }

    #[test]
    fn all_mood_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        for path in MoodPath::all() {
            let effective = entity.get_effective(StatePath::Mood(path)).unwrap();
            assert!(effective >= -1.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::Mood(path));
            assert!(base.is_some());

            let delta = entity.get_delta(StatePath::Mood(path));
            assert!(delta.is_some());
        }
    }

    #[test]
    fn hexaco_paths_base_and_effective() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Test each HEXACO path individually to cover all match arms
        let openness = entity
            .get_effective(StatePath::Hexaco(HexacoPath::Openness))
            .unwrap();
        let conscientiousness = entity
            .get_effective(StatePath::Hexaco(HexacoPath::Conscientiousness))
            .unwrap();
        let extraversion = entity
            .get_effective(StatePath::Hexaco(HexacoPath::Extraversion))
            .unwrap();
        let agreeableness = entity
            .get_effective(StatePath::Hexaco(HexacoPath::Agreeableness))
            .unwrap();
        let neuroticism = entity
            .get_effective(StatePath::Hexaco(HexacoPath::Neuroticism))
            .unwrap();
        let honesty = entity
            .get_effective(StatePath::Hexaco(HexacoPath::HonestyHumility))
            .unwrap();

        // All should be in valid range
        for v in [
            openness,
            conscientiousness,
            extraversion,
            agreeableness,
            neuroticism,
            honesty,
        ] {
            assert!(v >= -1.0 && v <= 1.0);
        }

        // Test base values
        for path in HexacoPath::all() {
            let base = entity.get_base(StatePath::Hexaco(path)).unwrap();
            let effective = entity.get_effective(StatePath::Hexaco(path)).unwrap();
            // Use larger epsilon due to f32 -> f64 conversion precision
            assert!((base - effective).abs() < 1e-6);
        }
    }

    #[test]
    fn mood_paths_base_delta_effective() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Add deltas
        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(0.2);
        entity
            .individual_state_mut()
            .mood_mut()
            .add_arousal_delta(0.3);
        entity
            .individual_state_mut()
            .mood_mut()
            .add_dominance_delta(0.4);

        // Test valence
        let valence_delta = entity
            .get_delta(StatePath::Mood(MoodPath::Valence))
            .unwrap();
        // Use larger epsilon due to f32 -> f64 conversion precision
        assert!((valence_delta - 0.2).abs() < 1e-6);

        // Test arousal
        let arousal_delta = entity
            .get_delta(StatePath::Mood(MoodPath::Arousal))
            .unwrap();
        assert!((arousal_delta - 0.3).abs() < 1e-6);

        // Test dominance
        let dominance_delta = entity
            .get_delta(StatePath::Mood(MoodPath::Dominance))
            .unwrap();
        assert!((dominance_delta - 0.4).abs() < 1e-6);

        // Test base (should be 0 for default)
        let valence_base = entity.get_base(StatePath::Mood(MoodPath::Valence)).unwrap();
        let arousal_base = entity.get_base(StatePath::Mood(MoodPath::Arousal)).unwrap();
        let dominance_base = entity
            .get_base(StatePath::Mood(MoodPath::Dominance))
            .unwrap();

        assert!(valence_base.abs() < 1e-6);
        assert!(arousal_base.abs() < 1e-6);
        assert!(dominance_base.abs() < 1e-6);
    }

    #[test]
    fn needs_paths_base_delta_effective() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Test each needs path individually
        let paths = [
            NeedsPath::Fatigue,
            NeedsPath::Stress,
            NeedsPath::Purpose,
        ];

        for path in paths {
            let effective = entity.get_effective(StatePath::Needs(path)).unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::Needs(path)).unwrap();
            assert!(base >= 0.0 && base <= 1.0);

            let delta = entity.get_delta(StatePath::Needs(path)).unwrap();
            // Use larger epsilon due to f32 -> f64 conversion precision
            assert!(delta.abs() < 1e-6); // Default delta is 0
        }
    }

    #[test]
    fn social_cognition_paths_base_delta_effective() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let paths = [
            SocialCognitionPath::Loneliness,
            SocialCognitionPath::PerceivedReciprocalCaring,
            SocialCognitionPath::PerceivedLiability,
            SocialCognitionPath::SelfHate,
            SocialCognitionPath::PerceivedCompetence,
        ];

        for path in paths {
            let effective = entity
                .get_effective(StatePath::SocialCognition(path))
                .unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::SocialCognition(path)).unwrap();
            assert!(base >= 0.0 && base <= 1.0);

            let delta = entity.get_delta(StatePath::SocialCognition(path)).unwrap();
            assert!(delta.abs() < 1e-6);
        }
    }

    #[test]
    fn query_affective_state_returns_pure_pad_dimensions() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let affective = entity.query_affective_state();

        // AffectiveState should only contain PAD dimensions
        assert!(affective.valence >= -1.0 && affective.valence <= 1.0);
        assert!(affective.arousal >= -1.0 && affective.arousal <= 1.0);
        assert!(affective.dominance >= -1.0 && affective.dominance <= 1.0);
    }

    #[test]
    fn query_physiological_state_returns_fatigue_and_stress() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let physiological = entity.query_physiological_state();

        // PhysiologicalState contains fatigue and stress
        assert!(physiological.fatigue >= 0.0 && physiological.fatigue <= 1.0);
        assert!(physiological.stress >= 0.0 && physiological.stress <= 1.0);
    }

    #[test]
    fn get_baseline_affect_returns_base_values_only() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        {
            let state = entity.individual_state_mut();
            state.mood_mut().valence_mut().set_base(0.1);
            state.mood_mut().arousal_mut().set_base(0.2);
            state.mood_mut().dominance_mut().set_base(-0.1);

            state.mood_mut().add_valence_delta(0.5);
        }

        let baseline = entity.get_baseline_affect();

        // Baseline should return base values only (no deltas)
        assert!((baseline.valence - 0.1).abs() < f32::EPSILON);
        assert!((baseline.arousal - 0.2).abs() < f32::EPSILON);
        assert!((baseline.dominance - (-0.1)).abs() < f32::EPSILON);
    }

    #[test]
    fn get_baseline_physiological_returns_base_values_only() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        {
            let state = entity.individual_state_mut();
            state.needs_mut().fatigue_mut().set_base(0.3);
            state.needs_mut().stress_mut().set_base(0.4);

            state.needs_mut().add_stress_delta(0.2);
        }

        let baseline = entity.get_baseline_physiological();

        // Baseline should return base values only (no deltas)
        assert!((baseline.fatigue - 0.3).abs() < f32::EPSILON);
        assert!((baseline.stress - 0.4).abs() < f32::EPSILON);
    }

    #[test]
    fn baseline_vs_effective_differ_when_deltas_present() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(0.4);
        entity
            .individual_state_mut()
            .needs_mut()
            .add_fatigue_delta(0.2);

        let baseline = entity.get_baseline_affect();
        let effective = entity.query_affective_state();

        // Valence should differ between baseline and effective
        assert!((effective.valence - baseline.valence).abs() > f32::EPSILON);

        // For physiological state, check fatigue differs
        let phys_baseline = entity.get_baseline_physiological();
        let phys_effective = entity.query_physiological_state();
        assert!((phys_effective.fatigue - phys_baseline.fatigue).abs() > f32::EPSILON);
    }

    #[test]
    fn affective_state_is_pure_pad() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        {
            let state = entity.individual_state_mut();
            state.mood_mut().valence_mut().set_base(0.2);
            state.mood_mut().arousal_mut().set_base(0.1);
            state.mood_mut().dominance_mut().set_base(0.0);

            state.mood_mut().add_valence_delta(0.1);
        }

        let affective = entity.query_affective_state();

        // AffectiveState should only contain PAD dimensions
        assert!((affective.valence - 0.3).abs() < 0.001);
        assert!((affective.arousal - 0.1).abs() < 0.001);
        assert!((affective.dominance - 0.0).abs() < 0.001);
    }

    #[test]
    fn physiological_state_separate_from_pad() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        {
            let state = entity.individual_state_mut();
            state.needs_mut().fatigue_mut().set_base(0.5);
            state.needs_mut().stress_mut().set_base(0.4);

            state.needs_mut().add_stress_delta(-0.2);
        }

        let physiological = entity.query_physiological_state();

        // PhysiologicalState should contain fatigue and stress
        assert!((physiological.fatigue - 0.5).abs() < 0.001);
        assert!((physiological.stress - 0.2).abs() < 0.001);
    }

    #[test]
    fn mental_health_all_stored_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Stored paths (not computed)
        let stored_paths = [
            MentalHealthPath::Depression,
            MentalHealthPath::SelfWorth,
            MentalHealthPath::Hopelessness,
            MentalHealthPath::InterpersonalHopelessness,
            MentalHealthPath::AcquiredCapability,
        ];

        for path in stored_paths {
            let effective = entity.get_effective(StatePath::MentalHealth(path)).unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::MentalHealth(path));
            assert!(base.is_some());

            let delta = entity.get_delta(StatePath::MentalHealth(path));
            assert!(delta.is_some());
        }
    }

    #[test]
    fn mental_health_all_computed_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Computed paths
        let computed_paths = [
            MentalHealthPath::ThwartedBelongingness,
            MentalHealthPath::PerceivedBurdensomeness,
            MentalHealthPath::SuicidalDesire,
            MentalHealthPath::AttemptRisk,
        ];

        for path in computed_paths {
            let effective = entity.get_effective(StatePath::MentalHealth(path)).unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::MentalHealth(path));
            assert!(base.is_none());

            let delta = entity.get_delta(StatePath::MentalHealth(path));
            assert!(delta.is_none());
        }
    }

    #[test]
    fn disposition_paths_base_delta_effective() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Test each disposition path individually
        let paths = [
            DispositionPath::ImpulseControl,
            DispositionPath::Empathy,
            DispositionPath::Aggression,
            DispositionPath::Grievance,
            DispositionPath::Reactance,
            DispositionPath::TrustPropensity,
        ];

        for path in paths {
            let effective = entity.get_effective(StatePath::Disposition(path)).unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::Disposition(path)).unwrap();
            assert!(base >= 0.0 && base <= 1.0);

            let delta = entity.get_delta(StatePath::Disposition(path)).unwrap();
            // Check delta is valid
            let _ = delta;
        }
    }

    #[test]
    fn person_characteristics_all_stored_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Stored paths (not composite)
        let stored_paths = [
            PersonCharacteristicsPath::CognitiveAbility,
            PersonCharacteristicsPath::EmotionalRegulationAssets,
            PersonCharacteristicsPath::SocialCapital,
            PersonCharacteristicsPath::MaterialSecurity,
            PersonCharacteristicsPath::ExperienceDiversity,
            PersonCharacteristicsPath::BaselineMotivation,
            PersonCharacteristicsPath::PersistenceTendency,
            PersonCharacteristicsPath::CuriosityTendency,
        ];

        for path in stored_paths {
            let effective = entity
                .get_effective(StatePath::PersonCharacteristics(path))
                .unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::PersonCharacteristics(path));
            assert!(base.is_some());

            let delta = entity.get_delta(StatePath::PersonCharacteristics(path));
            assert!(delta.is_some());
        }
    }

    #[test]
    fn person_characteristics_all_composite_paths() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Composite paths
        let composite_paths = [
            PersonCharacteristicsPath::Resource,
            PersonCharacteristicsPath::Force,
        ];

        for path in composite_paths {
            let effective = entity
                .get_effective(StatePath::PersonCharacteristics(path))
                .unwrap();
            assert!(effective >= 0.0 && effective <= 1.0);

            let base = entity.get_base(StatePath::PersonCharacteristics(path));
            assert!(base.is_none());

            let delta = entity.get_delta(StatePath::PersonCharacteristics(path));
            assert!(delta.is_none());
        }
    }

    #[test]
    fn relationship_slots_mut_internal() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Access mutable slots (internal method)
        let slots = entity.relationship_slots_mut();
        assert_eq!(slots.len(), MAX_RELATIONSHIP_SLOTS);

        // Verify we can modify slots
        let id = crate::types::RelationshipId::new("rel_test").unwrap();
        slots[0].attach(id.clone());

        assert!(entity.relationship_slots()[0].is_attached());
        assert_eq!(entity.relationship_slots()[0].get_attached(), Some(id));
    }

    // --- Memory Tests ---

    #[test]
    fn entity_memories_empty_initially() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        assert!(entity.memories().is_empty());
        assert_eq!(entity.memories().total_count(), 0);
    }

    #[test]
    fn entity_memories_mut_add_to_layer() {
        use crate::memory::{MemoryEntry, MemoryLayer};

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Add a memory via mutable access
        let entry = MemoryEntry::new(Duration::days(10), "Test memory");
        entity.memories_mut().add(MemoryLayer::Immediate, entry);

        // Verify memory was added
        assert_eq!(entity.memories().immediate_count(), 1);
        assert_eq!(entity.memories().total_count(), 1);
    }

    #[test]
    fn entity_mood_snapshot_captures_current_mood() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Modify mood
        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(0.5);
        entity
            .individual_state_mut()
            .mood_mut()
            .add_arousal_delta(0.3);
        entity
            .individual_state_mut()
            .mood_mut()
            .add_dominance_delta(-0.2);

        let snapshot = entity.mood_snapshot();

        assert!((snapshot.valence() - 0.5).abs() < 0.01);
        assert!((snapshot.arousal() - 0.3).abs() < 0.01);
        assert!((snapshot.dominance() - (-0.2)).abs() < 0.01);
    }

    #[test]
    fn entity_create_memory_selects_layer_by_salience() {
        use crate::memory::MemoryTag;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let participant = crate::types::EntityId::new("other_001").unwrap();
        // Salience 0.7+ -> Legacy layer
        let memory = entity.create_memory(
            "Test memory",
            vec![participant],
            vec![MemoryTag::Personal],
            0.7,
            None,
        );

        assert_eq!(entity.memories().legacy_count(), 1);
        assert_eq!(memory.summary(), "Test memory");
    }

    #[test]
    fn entity_create_memory_in_layer_explicit() {
        use crate::memory::{MemoryLayer, MemoryTag};

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let participant = crate::types::EntityId::new("other_001").unwrap();
        // Explicit layer selection overrides salience-based default
        let memory = entity.create_memory_in_layer(
            MemoryLayer::ShortTerm,
            "Test memory",
            vec![participant],
            vec![MemoryTag::Personal],
            0.7,
            None,
        );

        assert_eq!(entity.memories().short_term_count(), 1);
        assert_eq!(memory.summary(), "Test memory");
    }

    #[test]
    fn entity_create_memory_captures_mood() {
        use crate::memory::MemoryTag;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Set specific mood
        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(0.6);

        // Salience 0.8 -> Legacy layer
        let memory = entity.create_memory(
            "Happy memory",
            vec![],
            vec![MemoryTag::Achievement],
            0.8,
            None,
        );

        // Verify the returned memory captured the mood
        assert!((memory.emotional_snapshot().valence() - 0.6).abs() < 0.01);

        // Verify the memory stored in layers also has the mood
        let memories = entity.memories().legacy();
        assert_eq!(memories.len(), 1);
        assert!((memories[0].emotional_snapshot().valence() - 0.6).abs() < 0.01);
    }

    #[test]
    fn entity_create_memory_with_context() {
        use crate::memory::MemoryTag;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let context = crate::types::MicrosystemId::new("work_001").unwrap();
        // Salience 0.5 -> Long-term layer
        let memory = entity.create_memory(
            "Work memory",
            vec![],
            vec![MemoryTag::Mission],
            0.5,
            Some(context.clone()),
        );

        // Verify returned memory has context
        assert_eq!(memory.microsystem_context(), Some(&context));

        let results = entity.memories().retrieve_by_context(&context);
        assert_eq!(results.len(), 1);
    }

    #[test]
    fn layer_for_salience_immediate() {
        use crate::memory::MemoryLayer;

        // Low salience (0.0-0.3) -> Immediate
        assert_eq!(Entity::layer_for_salience(0.0), MemoryLayer::Immediate);
        assert_eq!(Entity::layer_for_salience(0.1), MemoryLayer::Immediate);
        assert_eq!(Entity::layer_for_salience(0.29), MemoryLayer::Immediate);
    }

    #[test]
    fn layer_for_salience_short_term() {
        use crate::memory::MemoryLayer;

        // Notable salience (0.3-0.5) -> ShortTerm
        assert_eq!(Entity::layer_for_salience(0.3), MemoryLayer::ShortTerm);
        assert_eq!(Entity::layer_for_salience(0.4), MemoryLayer::ShortTerm);
        assert_eq!(Entity::layer_for_salience(0.49), MemoryLayer::ShortTerm);
    }

    #[test]
    fn layer_for_salience_long_term() {
        use crate::memory::MemoryLayer;

        // Significant salience (0.5-0.7) -> LongTerm
        assert_eq!(Entity::layer_for_salience(0.5), MemoryLayer::LongTerm);
        assert_eq!(Entity::layer_for_salience(0.6), MemoryLayer::LongTerm);
        assert_eq!(Entity::layer_for_salience(0.69), MemoryLayer::LongTerm);
    }

    #[test]
    fn layer_for_salience_legacy() {
        use crate::memory::MemoryLayer;

        // High salience (0.7+) -> Legacy
        assert_eq!(Entity::layer_for_salience(0.7), MemoryLayer::Legacy);
        assert_eq!(Entity::layer_for_salience(0.8), MemoryLayer::Legacy);
        assert_eq!(Entity::layer_for_salience(0.9), MemoryLayer::Legacy);
        assert_eq!(Entity::layer_for_salience(1.0), MemoryLayer::Legacy);
    }

    #[test]
    fn entity_recall_mood_congruent() {
        use crate::memory::{EmotionalSnapshot, MemoryEntry, MemoryLayer};

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Add memory with specific emotional snapshot
        let entry = MemoryEntry::new(Duration::days(10), "Happy memory")
            .with_emotional_snapshot(EmotionalSnapshot::new(0.8, 0.3, 0.2))
            .with_salience(0.7);
        entity.memories_mut().add(MemoryLayer::ShortTerm, entry);

        // Set mood to similar values
        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(0.8);
        entity
            .individual_state_mut()
            .mood_mut()
            .add_arousal_delta(0.3);
        entity
            .individual_state_mut()
            .mood_mut()
            .add_dominance_delta(0.2);

        // Should find the congruent memory
        let results = entity.recall_mood_congruent(0.9);
        assert_eq!(results.len(), 1);
    }

    #[test]
    fn entity_recall_mood_congruent_empty_when_no_match() {
        use crate::memory::{EmotionalSnapshot, MemoryEntry, MemoryLayer};

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Add memory with positive emotional snapshot
        let entry = MemoryEntry::new(Duration::days(10), "Happy memory")
            .with_emotional_snapshot(EmotionalSnapshot::new(1.0, 1.0, 1.0))
            .with_salience(0.7);
        entity.memories_mut().add(MemoryLayer::ShortTerm, entry);

        // Set mood to opposite values
        entity
            .individual_state_mut()
            .mood_mut()
            .add_valence_delta(-0.8);
        entity
            .individual_state_mut()
            .mood_mut()
            .add_arousal_delta(-0.8);
        entity
            .individual_state_mut()
            .mood_mut()
            .add_dominance_delta(-0.8);

        // Should not find congruent memory with high threshold
        let results = entity.recall_mood_congruent(0.9);
        assert!(results.is_empty());
    }

    // --- Alert Tests ---

    #[test]
    fn entity_starts_with_no_alerts() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        assert!(entity.alerts().is_empty());
    }

    #[test]
    fn entity_can_accumulate_alerts() {
        use crate::enums::{AlertSeverity, AlertTrigger, SpiralType};

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Add first alert
        let alert1 = Alert::new(
            AlertSeverity::Warning,
            AlertTrigger::spiral(SpiralType::Stress),
            Duration::days(1),
            "First alert",
        );
        entity.push_alert(alert1);
        assert_eq!(entity.alerts().len(), 1);

        // Add second alert
        let alert2 = Alert::new(
            AlertSeverity::Critical,
            AlertTrigger::spiral(SpiralType::Depression),
            Duration::days(2),
            "Second alert",
        );
        entity.push_alert(alert2);
        assert_eq!(entity.alerts().len(), 2);
    }

    #[test]
    fn entity_clear_alerts() {
        use crate::enums::{AlertSeverity, AlertTrigger, SpiralType};

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        entity.push_alert(Alert::new(
            AlertSeverity::Warning,
            AlertTrigger::spiral(SpiralType::Stress),
            Duration::days(1),
            "Test alert",
        ));
        assert!(!entity.alerts().is_empty());

        entity.clear_alerts();
        assert!(entity.alerts().is_empty());
    }

    #[test]
    fn entity_take_alerts() {
        use crate::enums::{AlertSeverity, AlertTrigger, SpiralType};

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        entity.push_alert(Alert::new(
            AlertSeverity::Warning,
            AlertTrigger::spiral(SpiralType::Stress),
            Duration::days(1),
            "Test alert",
        ));

        let alerts = entity.take_alerts();
        assert_eq!(alerts.len(), 1);
        assert!(entity.alerts().is_empty());
    }

    // --- Entity context methods coverage ---

    #[test]
    fn entity_context_accessor() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let ctx = entity.context();
        assert_eq!(ctx.microsystem_count(), 0);
    }

    #[test]
    fn entity_context_mut_accessor() {
        use crate::context::{Microsystem, WorkContext};
        use crate::types::MicrosystemId;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let work_id = MicrosystemId::new("work").unwrap();
        entity
            .context_mut()
            .add_microsystem(work_id, Microsystem::new_work(WorkContext::default()));

        assert_eq!(entity.context().microsystem_count(), 1);
    }

    #[test]
    fn entity_get_context_method() {
        use crate::enums::{ContextPath, MacrosystemPath};

        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let value = entity.get_context(&ContextPath::Macrosystem(MacrosystemPath::PowerDistance));
        assert!(value.is_some());
        assert!(value.unwrap() >= 0.0 && value.unwrap() <= 1.0);
    }

    #[test]
    fn entity_set_context_method() {
        use crate::enums::{ContextPath, MacrosystemPath};

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let result = entity.set_context(
            &ContextPath::Macrosystem(MacrosystemPath::CulturalStress),
            0.7,
        );
        assert!(result);

        let value = entity
            .get_context(&ContextPath::Macrosystem(MacrosystemPath::CulturalStress))
            .unwrap();
        assert!((value - 0.7).abs() < f64::EPSILON);
    }

    // --- Bidirectional Context Processing Tests ---

    #[test]
    fn advance_context_to_person_applies_stress() {
        use crate::context::{Microsystem, WorkContext};
        use crate::types::MicrosystemId;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Add high-stress work context
        let work_id = MicrosystemId::new("work").unwrap();
        let mut work = WorkContext::default();
        work.workload_stress = 0.9;
        entity
            .context_mut()
            .add_microsystem(work_id, Microsystem::new_work(work));

        let stress_before = entity.individual_state().needs().stress_effective();

        let processor = NoOpDecayProcessor::new();
        entity.advance(Duration::days(1), &processor);

        let stress_after = entity.individual_state().needs().stress_effective();

        // High context stress should increase person stress
        assert!(stress_after >= stress_before);
    }

    #[test]
    fn advance_person_to_context_shapes_warmth() {
        use crate::context::{Microsystem, SocialContext};
        use crate::state::Hexaco;
        use crate::types::MicrosystemId;

        // Create entity with high extraversion
        let hexaco = Hexaco::new().with_extraversion(0.8);
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .hexaco(hexaco)
            .build()
            .unwrap();

        // Add social context
        let social_id = MicrosystemId::new("social").unwrap();
        let mut social = SocialContext::default();
        social.warmth = 0.5;
        entity
            .context_mut()
            .add_microsystem(social_id.clone(), Microsystem::new_social(social));

        let warmth_before = entity
            .context()
            .get_microsystem(&social_id)
            .unwrap()
            .social()
            .unwrap()
            .warmth;

        let processor = NoOpDecayProcessor::new();
        entity.advance(Duration::days(1), &processor);

        let warmth_after = entity
            .context()
            .get_microsystem(&social_id)
            .unwrap()
            .social()
            .unwrap()
            .warmth;

        // High extraversion should increase social warmth
        assert!(warmth_after > warmth_before);
    }

    #[test]
    fn advance_bidirectional_processing_order() {
        use crate::context::{Microsystem, SocialContext, WorkContext};
        use crate::state::Hexaco;
        use crate::types::MicrosystemId;

        // Create entity with high extraversion
        let hexaco = Hexaco::new().with_extraversion(0.8);
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .hexaco(hexaco)
            .build()
            .unwrap();

        // Add work and social contexts
        let work_id = MicrosystemId::new("work").unwrap();
        let social_id = MicrosystemId::new("social").unwrap();

        let mut work = WorkContext::default();
        work.workload_stress = 0.8;
        entity
            .context_mut()
            .add_microsystem(work_id, Microsystem::new_work(work));

        let mut social = SocialContext::default();
        social.warmth = 0.5;
        entity
            .context_mut()
            .add_microsystem(social_id.clone(), Microsystem::new_social(social));

        let processor = NoOpDecayProcessor::new();
        entity.advance(Duration::days(1), &processor);

        // Both effects should have applied:
        // 1. Context stress -> person stress (context-to-person)
        // 2. High extraversion -> social warmth (person-to-context)
        let warmth = entity
            .context()
            .get_microsystem(&social_id)
            .unwrap()
            .social()
            .unwrap()
            .warmth;

        assert!(warmth > 0.5); // Person shaped context
    }

    #[test]
    fn advance_invalidates_mesosystem_cache() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let processor = NoOpDecayProcessor::new();
        entity.advance(Duration::days(1), &processor);

        // After advance, cache should be invalidated
        assert!(!entity.context().mesosystem_cache().is_valid());
    }

    // --- Configuration Tests ---

    #[test]
    fn entity_has_config() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Human entities should have mental health enabled
        assert!(entity.config().mental_health_enabled());
    }

    #[test]
    fn entity_config_derived_from_species() {
        let human = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let dog = EntityBuilder::new().species(Species::Dog).build().unwrap();

        // Human has mental health tracking
        assert!(human.config().mental_health_enabled());

        // Dog does not have mental health tracking
        assert!(!dog.config().mental_health_enabled());
    }

    #[test]
    fn entity_config_mut_modifies_config() {
        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Start with mental health enabled
        assert!(entity.config().mental_health_enabled());

        // Disable it
        entity.config_mut().set_mental_health_enabled(false);
        assert!(!entity.config().mental_health_enabled());
    }

    // --- Proximal Process Gate Tests ---

    #[test]
    fn proximal_gate_blocks_low_frequency_effects() {
        use crate::context::{Microsystem, WorkContext};
        use crate::types::MicrosystemId;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Set high thresholds so the gate will block
        entity.config_mut().set_proximal_frequency_threshold(0.9);
        entity.config_mut().set_proximal_complexity_threshold(0.9);

        // Add low-interaction work context (below thresholds)
        let work_id = MicrosystemId::new("work").unwrap();
        let mut work = WorkContext::default();
        work.workload_stress = 0.9; // High stress
        work.interaction_profile.interaction_frequency = 0.2; // Low frequency (below threshold)
        work.interaction_profile.interaction_complexity = 0.2; // Low complexity (below threshold)
        entity
            .context_mut()
            .add_microsystem(work_id, Microsystem::new_work(work));

        let stress_before = entity.individual_state().needs().stress_effective();

        let processor = NoOpDecayProcessor::new();
        entity.advance(Duration::days(1), &processor);

        let stress_after = entity.individual_state().needs().stress_effective();

        // Stress should NOT have increased because proximal gate blocked effects
        // (allowing for small floating point differences)
        assert!((stress_after - stress_before).abs() < 0.01);
    }

    #[test]
    fn proximal_gate_allows_high_frequency_effects() {
        use crate::context::{Microsystem, WorkContext};
        use crate::types::MicrosystemId;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Use default thresholds (0.3)
        // Add high-interaction work context (above thresholds)
        let work_id = MicrosystemId::new("work").unwrap();
        let mut work = WorkContext::default();
        work.workload_stress = 0.9; // High stress
        work.interaction_profile.interaction_frequency = 0.8; // High frequency (above threshold)
        work.interaction_profile.interaction_complexity = 0.8; // High complexity (above threshold)
        entity
            .context_mut()
            .add_microsystem(work_id, Microsystem::new_work(work));

        let stress_before = entity.individual_state().needs().stress_effective();

        let processor = NoOpDecayProcessor::new();
        entity.advance(Duration::days(1), &processor);

        let stress_after = entity.individual_state().needs().stress_effective();

        // Stress should have increased because proximal gate allowed effects
        assert!(stress_after > stress_before);
    }

    #[test]
    fn proximal_gate_uses_relationship_quality_with_attachments() {
        use crate::context::{Microsystem, SocialContext};
        use crate::types::{MicrosystemId, RelationshipId};

        let mut attached = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let mut unattached = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let social_id = MicrosystemId::new("social").unwrap();
        let mut social = SocialContext::default();
        social.warmth = 0.1;
        social.interaction_profile.interaction_frequency = 0.8;
        social.interaction_profile.interaction_complexity = 0.8;

        attached
            .context_mut()
            .add_microsystem(social_id.clone(), Microsystem::new_social(social.clone()));
        unattached
            .context_mut()
            .add_microsystem(social_id, Microsystem::new_social(social));

        let rel_id = RelationshipId::new("rel_attached").unwrap();
        attached.relationship_slots_mut()[0].attach(rel_id);

        let processor = NoOpDecayProcessor::new();
        let loneliness_before_attached = attached
            .individual_state()
            .social_cognition()
            .loneliness_effective();
        let loneliness_before_unattached =
            unattached
                .individual_state()
                .social_cognition()
                .loneliness_effective();

        attached.advance(Duration::days(1), &processor);
        unattached.advance(Duration::days(1), &processor);

        let loneliness_after_attached = attached
            .individual_state()
            .social_cognition()
            .loneliness_effective();
        let loneliness_after_unattached =
            unattached
                .individual_state()
                .social_cognition()
                .loneliness_effective();

        assert!((loneliness_before_attached - loneliness_before_unattached).abs() < f32::EPSILON);
        assert!(loneliness_after_attached <= loneliness_after_unattached);
    }

    #[test]
    fn advance_skips_zero_adjustments() {
        use crate::context::{Microsystem, SocialContext};
        use crate::types::MicrosystemId;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let social_id = MicrosystemId::new("social").unwrap();
        let mut social = SocialContext::default();
        social.group_standing = 1.0;
        social.warmth = 1.0;
        social.hostility = 0.0;
        social.interaction_profile.interaction_frequency = 0.7;
        social.interaction_profile.interaction_complexity = 0.7;
        entity
            .context_mut()
            .add_microsystem(social_id, Microsystem::new_social(social));

        entity.context_mut().macrosystem_mut().cultural_stress = 0.0;
        entity
            .context_mut()
            .chronosystem_mut()
            .historical_period_mut()
            .stability_level = 1.0;

        let processor = NoOpDecayProcessor::new();
        let stress_before = entity.individual_state().needs().stress_effective();
        let loneliness_before = entity
            .individual_state()
            .social_cognition()
            .loneliness_effective();

        entity.advance(Duration::days(1), &processor);

        let stress_after = entity.individual_state().needs().stress_effective();
        let loneliness_after = entity
            .individual_state()
            .social_cognition()
            .loneliness_effective();

        assert!((stress_after - stress_before).abs() < f32::EPSILON);
        assert!((loneliness_after - loneliness_before).abs() < f32::EPSILON);
    }

    // --- Exosystem Effects Tests ---

    #[test]
    fn exosystem_effects_modify_stress_buffer() {
        use crate::context::{Microsystem, WorkContext};
        use crate::types::MicrosystemId;

        // Create two entities with different institutional support levels
        let mut entity_low_support = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let mut entity_high_support = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Set up identical stressful work contexts
        let work_id = MicrosystemId::new("work").unwrap();
        let mut work = WorkContext::default();
        work.workload_stress = 0.8;
        work.interaction_profile.interaction_frequency = 0.7;
        work.interaction_profile.interaction_complexity = 0.7;

        entity_low_support
            .context_mut()
            .add_microsystem(work_id.clone(), Microsystem::new_work(work.clone()));
        entity_high_support
            .context_mut()
            .add_microsystem(work_id, Microsystem::new_work(work));

        // Set different institutional support levels
        entity_low_support
            .context_mut()
            .exosystem_mut()
            .institutional_support = 0.2;
        entity_high_support
            .context_mut()
            .exosystem_mut()
            .institutional_support = 0.9;

        let processor = NoOpDecayProcessor::new();
        entity_low_support.advance(Duration::days(1), &processor);
        entity_high_support.advance(Duration::days(1), &processor);

        let stress_low = entity_low_support
            .individual_state()
            .needs()
            .stress_effective();
        let stress_high = entity_high_support
            .individual_state()
            .needs()
            .stress_effective();

        // High institutional support should buffer stress (lower stress than low support)
        assert!(stress_high < stress_low);
    }

    // --- Macrosystem Effects Tests ---

    #[test]
    fn macrosystem_effects_modify_belonging() {
        use crate::context::{Microsystem, SocialContext};
        use crate::enums::MacrosystemPath;
        use crate::types::MicrosystemId;

        // Create two entities with different cultural orientations
        let mut entity_individualist = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let mut entity_collectivist = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Set up identical social contexts
        let social_id = MicrosystemId::new("social").unwrap();
        let mut social = SocialContext::default();
        social.warmth = 0.5;
        social.interaction_profile.interaction_frequency = 0.7;
        social.interaction_profile.interaction_complexity = 0.7;

        entity_individualist
            .context_mut()
            .add_microsystem(social_id.clone(), Microsystem::new_social(social.clone()));
        entity_collectivist
            .context_mut()
            .add_microsystem(social_id, Microsystem::new_social(social));

        // Set cultural orientations
        // Individualist: +0.7, Collectivist: -0.7
        entity_individualist
            .context_mut()
            .macrosystem_mut()
            .set_value(&MacrosystemPath::IndividualismCollectivism, 0.7);
        entity_collectivist
            .context_mut()
            .macrosystem_mut()
            .set_value(&MacrosystemPath::IndividualismCollectivism, -0.7);

        let processor = NoOpDecayProcessor::new();
        entity_individualist.advance(Duration::days(1), &processor);
        entity_collectivist.advance(Duration::days(1), &processor);

        let loneliness_ind = entity_individualist
            .individual_state()
            .social_cognition()
            .loneliness_effective();
        let loneliness_col = entity_collectivist
            .individual_state()
            .social_cognition()
            .loneliness_effective();

        // Collectivist culture should reduce loneliness compared to individualist
        // (due to higher belonging need weight)
        assert!(loneliness_col <= loneliness_ind);
    }

    #[test]
    fn macrosystem_cultural_stress_affects_person() {
        use crate::context::{Microsystem, SocialContext};
        use crate::types::MicrosystemId;

        let mut entity_low_stress = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let mut entity_high_stress = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Set up identical social contexts
        let social_id = MicrosystemId::new("social").unwrap();
        let social = SocialContext::default();

        entity_low_stress
            .context_mut()
            .add_microsystem(social_id.clone(), Microsystem::new_social(social.clone()));
        entity_high_stress
            .context_mut()
            .add_microsystem(social_id, Microsystem::new_social(social));

        // Set different cultural stress levels
        entity_low_stress
            .context_mut()
            .macrosystem_mut()
            .cultural_stress = 0.1;
        entity_high_stress
            .context_mut()
            .macrosystem_mut()
            .cultural_stress = 0.9;

        let processor = NoOpDecayProcessor::new();
        entity_low_stress.advance(Duration::days(1), &processor);
        entity_high_stress.advance(Duration::days(1), &processor);

        let stress_low = entity_low_stress
            .individual_state()
            .needs()
            .stress_effective();
        let stress_high = entity_high_stress
            .individual_state()
            .needs()
            .stress_effective();

        // High cultural stress should increase person stress
        assert!(stress_high > stress_low);
    }

    // --- Chronosystem Effects Tests ---

    #[test]
    fn chronosystem_offtime_penalty_applied() {
        use crate::context::{Microsystem, NormativeTransition, SocialContext};
        use crate::types::MicrosystemId;

        let mut entity_ontime = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let mut entity_offtime = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Set up identical social contexts
        let social_id = MicrosystemId::new("social").unwrap();
        let social = SocialContext::default();

        entity_ontime
            .context_mut()
            .add_microsystem(social_id.clone(), Microsystem::new_social(social.clone()));
        entity_offtime
            .context_mut()
            .add_microsystem(social_id, Microsystem::new_social(social));

        // Add on-time transition to first entity
        let mut on_time_transition = NormativeTransition::new("marriage", 27.5, 5.0, false);
        on_time_transition.complete(28.0); // On-time
        entity_ontime
            .context_mut()
            .chronosystem_mut()
            .add_normative_transition(on_time_transition);

        // Add off-time (very late) transition to second entity
        let mut off_time_transition = NormativeTransition::new("marriage", 27.5, 5.0, false);
        off_time_transition.complete(45.0); // Very late
        entity_offtime
            .context_mut()
            .chronosystem_mut()
            .add_normative_transition(off_time_transition);

        let processor = NoOpDecayProcessor::new();
        entity_ontime.advance(Duration::days(1), &processor);
        entity_offtime.advance(Duration::days(1), &processor);

        let stress_ontime = entity_ontime.individual_state().needs().stress_effective();
        let stress_offtime = entity_offtime.individual_state().needs().stress_effective();

        // Off-time transition should result in higher stress
        assert!(stress_offtime > stress_ontime);
    }

    #[test]
    fn chronosystem_instability_affects_stress() {
        use crate::context::{Microsystem, SocialContext};
        use crate::enums::ChronosystemPath;
        use crate::types::MicrosystemId;

        let mut entity_stable = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let mut entity_unstable = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Set up identical social contexts
        let social_id = MicrosystemId::new("social").unwrap();
        let social = SocialContext::default();

        entity_stable
            .context_mut()
            .add_microsystem(social_id.clone(), Microsystem::new_social(social.clone()));
        entity_unstable
            .context_mut()
            .add_microsystem(social_id, Microsystem::new_social(social));

        // Set different stability levels
        entity_stable
            .context_mut()
            .chronosystem_mut()
            .set_value(&ChronosystemPath::StabilityLevel, 0.9); // High stability
        entity_unstable
            .context_mut()
            .chronosystem_mut()
            .set_value(&ChronosystemPath::StabilityLevel, 0.1); // Low stability

        let processor = NoOpDecayProcessor::new();
        entity_stable.advance(Duration::days(1), &processor);
        entity_unstable.advance(Duration::days(1), &processor);

        let stress_stable = entity_stable.individual_state().needs().stress_effective();
        let stress_unstable = entity_unstable
            .individual_state()
            .needs()
            .stress_effective();

        // Low stability (high instability) should result in higher stress
        assert!(stress_unstable > stress_stable);
    }

    // --- Aggregate Interaction Metrics Tests ---

    #[test]
    fn compute_aggregate_metrics_empty_context() {
        let entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let (freq, complex) = entity.compute_aggregate_interaction_metrics();
        assert!((freq - 0.0).abs() < f64::EPSILON);
        assert!((complex - 0.0).abs() < f64::EPSILON);
    }

    #[test]
    fn compute_aggregate_metrics_single_microsystem() {
        use crate::context::{Microsystem, WorkContext};
        use crate::types::MicrosystemId;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        let work_id = MicrosystemId::new("work").unwrap();
        let mut work = WorkContext::default();
        work.interaction_profile.interaction_frequency = 0.7;
        work.interaction_profile.interaction_complexity = 0.5;
        entity
            .context_mut()
            .add_microsystem(work_id, Microsystem::new_work(work));

        let (freq, complex) = entity.compute_aggregate_interaction_metrics();
        assert!((freq - 0.7).abs() < f64::EPSILON);
        assert!((complex - 0.5).abs() < f64::EPSILON);
    }

    #[test]
    fn compute_aggregate_metrics_multiple_microsystems() {
        use crate::context::{Microsystem, SocialContext, WorkContext};
        use crate::types::MicrosystemId;

        let mut entity = EntityBuilder::new()
            .species(Species::Human)
            .build()
            .unwrap();

        // Add work context
        let work_id = MicrosystemId::new("work").unwrap();
        let mut work = WorkContext::default();
        work.interaction_profile.interaction_frequency = 0.6;
        work.interaction_profile.interaction_complexity = 0.4;
        entity
            .context_mut()
            .add_microsystem(work_id, Microsystem::new_work(work));

        // Add social context
        let social_id = MicrosystemId::new("social").unwrap();
        let mut social = SocialContext::default();
        social.interaction_profile.interaction_frequency = 0.8;
        social.interaction_profile.interaction_complexity = 0.6;
        entity
            .context_mut()
            .add_microsystem(social_id, Microsystem::new_social(social));

        let (freq, complex) = entity.compute_aggregate_interaction_metrics();
        // Average of 0.6 and 0.8 = 0.7
        assert!((freq - 0.7).abs() < f64::EPSILON);
        // Average of 0.4 and 0.6 = 0.5
        assert!((complex - 0.5).abs() < f64::EPSILON);
    }
}
